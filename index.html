<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Index &mdash; Deterministic Annealing 1.0 documentation</title>
    
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="Deterministic Annealing 1.0 documentation" href="#" />
    <link rel="next" title="detan.detan – deterministic annealing library" href="detan.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="index">
<h1>Index<a class="headerlink" href="#index" title="Permalink to this headline">¶</a></h1>
<div class="section" id="modules">
<h2>Modules<a class="headerlink" href="#modules" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="detan.html"><code class="docutils literal"><span class="pre">detan.detan</span></code> &#8211; deterministic annealing library</a></li>
</ul>
</div>
</div>
</div>
<div class="section" id="deterministic-annealing">
<h1>Deterministic Annealing<a class="headerlink" href="#deterministic-annealing" title="Permalink to this headline">¶</a></h1>
<p><code class="docutils literal"><span class="pre">detan</span></code> is a Python 3 library for deterministic annealing, a clustering
algorithm that uses fixed point iteration. It is based on <em>T. Hofmann and J. M.
Buhmann, Pairwise data clustering by deterministic annealing, IEEE T. Pattern
Anal., 19 (1997), pp. 1–14.</em></p>
<div class="section" id="installation">
<h2>Installation<a class="headerlink" href="#installation" title="Permalink to this headline">¶</a></h2>
<p>You can install directly from this git repository using:</p>
<div class="code text highlight-default"><div class="highlight"><pre><span></span><span class="n">pip</span> <span class="n">install</span> <span class="n">git</span><span class="o">+</span><span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">detly</span><span class="o">/</span><span class="n">detan</span><span class="o">.</span><span class="n">git</span>
</pre></div>
</div>
<p>...or you can clone the git repository however you prefer, and do:</p>
<div class="code text highlight-default"><div class="highlight"><pre><span></span><span class="n">pip</span> <span class="n">install</span> <span class="o">.</span>
</pre></div>
</div>
<p>...or:</p>
<div class="code text highlight-default"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="n">setup</span><span class="o">.</span><span class="n">py</span> <span class="n">install</span>
</pre></div>
</div>
<p>...from the cloned tree.</p>
<div class="section" id="dependencies">
<h3>Dependencies<a class="headerlink" href="#dependencies" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>numpy</li>
</ul>
</div>
</div>
<div class="section" id="clustering-algorithms">
<h2>Clustering algorithms<a class="headerlink" href="#clustering-algorithms" title="Permalink to this headline">¶</a></h2>
<p>Deterministic annealing is a clustering algorithm. So what do I consider a
clustering algorithm in general?</p>
<p>Say you have a collection of <code class="docutils literal"><span class="pre">N</span></code> things. They could be signals, or images, or
something else altogether. Say also that you have some way of measuring the
dissimilarity of each pair of things. This doesn&#8217;t need to be distance in a
vector space (although it could be) — as long as there&#8217;s a well defined and
symmetric way to measure the dissimilarity between any two of your things, that
will work.</p>
<p>I will call this dissimilarity the &#8220;pairwise distance measure&#8221; or just
&#8220;distance&#8221; from now on, but it&#8217;s important to remember the note above: it
doesn&#8217;t have to be a conventional distance (eg. the Euclidean norm). It just has
to be:</p>
<ul class="simple">
<li>symmetric: <code class="docutils literal"><span class="pre">distance(A,</span> <span class="pre">B)</span> <span class="pre">==</span> <span class="pre">distance(B,</span> <span class="pre">A)</span></code></li>
<li>well defined: <code class="docutils literal"><span class="pre">distance(A,</span> <span class="pre">B)</span> <span class="pre">==</span> <span class="pre">distance(C,</span> <span class="pre">D)</span></code> whenever <code class="docutils literal"><span class="pre">A</span> <span class="pre">==</span> <span class="pre">C</span></code> and
<code class="docutils literal"><span class="pre">B</span> <span class="pre">==</span> <span class="pre">D</span></code></li>
</ul>
<p>Finally, say you know that there are <code class="docutils literal"><span class="pre">k</span></code> natural groupings of these objects.
<em>Clustering</em> is a way of computing which things go in which group based on their
distances.</p>
<p>All that a clustering algorithm cares about is the dissimilarity measure and the
number of groups. Given an <code class="docutils literal"><span class="pre">N</span> <span class="pre">×</span> <span class="pre">N</span></code> matrix of your distances (which should be
symmetric), and the number of groups <code class="docutils literal"><span class="pre">k</span></code>, clustering will produce an
<em>assignment matrix</em> that says which things go into which group.</p>
<p>The assignment matrix is a <code class="docutils literal"><span class="pre">N</span> <span class="pre">×</span> <span class="pre">k</span></code> matrix. Ideally the assignment matrix will
contain only zeros and ones, where a one in row <code class="docutils literal"><span class="pre">i</span></code> and column <code class="docutils literal"><span class="pre">j</span></code> means
that thing <code class="docutils literal"><span class="pre">i</span></code> goes in group <code class="docutils literal"><span class="pre">j</span></code> (and zero means the opposite). The matrix
should satisfy the following three conditions:</p>
<ul class="simple">
<li>binary: each entry is either 0 or 1</li>
<li>exclusive, and exhaustive: each row contains exactly one <code class="docutils literal"><span class="pre">1</span></code>, because each
thing can must belong to one and only one group</li>
</ul>
<p>For example, this matrix:</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="33%" />
<col width="33%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr class="row-even"><td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="row-even"><td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="row-even"><td>0</td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>...means that thing #0 goes in group #1, things #1, #2 and #4 go in group #0,
and things #3 and #5 go in group #2. The order of the groups doesn&#8217;t matter; any
permutation of the columns would result in an equivalent assignment matrix.</p>
<p>Deterministic annealing is an algorithm that takes such a distance matrix and
<em>approximates</em> the assignment matrix.</p>
</div>
<div class="section" id="how-deterministic-annealing-works">
<h2>How deterministic annealing works<a class="headerlink" href="#how-deterministic-annealing-works" title="Permalink to this headline">¶</a></h2>
<p>The assignment matrix is the ideal outcome of a clustering algorithm, but it is
not quite what deterministic annealing calculates. Deterministic annealing (or
<em>DA</em>) works on the <em>expectation values</em> of the assignments. Instead of a matrix
of zeros and ones, DA iterates over a matrix of values <em>between</em> zero and one.
DA gradually converges these expectation values towards the optimal zero or one
for that &#8220;thing&#8221; and &#8220;group&#8221;.</p>
<p>DA works at two levels, which will probably manifest in your code as two nested
loops. The outer loop will gradually lower the temperature parameter, and the
inner loop will update the expectation values.</p>
<p>Updating the expectation values has two parts. First, we calculate &#8220;potentials&#8221;
from the expectation values and distances (so named because they&#8217;re an analogue
of potential energy in a physical system). Second, we calculate new expectations
from the potentials and the Lagrangian parameter <code class="docutils literal"><span class="pre">T</span></code> (so named because it&#8217;s
analogous to temperature in a physical system). This is a form of fixed point
iteration, ie. repeatedly calculating <code class="docutils literal"><span class="pre">x_(n+1)</span> <span class="pre">=</span> <span class="pre">f(x_n)</span></code> until we decide we&#8217;ve
found the solution.</p>
</div>
<div class="section" id="limitations-and-modes-of-failure">
<h2>Limitations and modes of failure<a class="headerlink" href="#limitations-and-modes-of-failure" title="Permalink to this headline">¶</a></h2>
<p>There is no intrinsically obvious point at which to stop iterating and lower the
temperature, nor is there an obvious point to stop lowering the temperature. It
is entirely dependent on context and the statistics of the distances.</p>
<p>A common criteria for stopping fixed point iteration (the inner loop) is to
calculate the absolute difference between the last value and the current value
and stop when this difference drops below a threshold:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">new_assignments</span> <span class="ow">in</span> <span class="n">annealer</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">new_assignments</span> <span class="o">-</span> <span class="n">old_assignments</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">tolerance</span><span class="p">:</span>
        <span class="k">break</span>
    <span class="n">old_assignments</span> <span class="o">=</span> <span class="n">new_assignments</span>
</pre></div>
</div>
<p>Deciding when to stop lowering the temperature is more context dependent; the
two ways I&#8217;ve used have been to:</p>
<ul class="simple">
<li>have a fixed number of iterations (eg. 20)</li>
<li>to look at the maximum distance of the assignment expectations from zero and
one</li>
</ul>
<p>This may take some trial and error in your application to determine what works
best.</p>
<p>Another complication arises because of numerical precision. If a thing is
&#8220;close&#8221; to being in more than one group, the expected assignments could differ
by less than what a computer&#8217;s numerical precision can express. In this case,
there will be two identical entries in a row of the matrix, and they might both
converge towards <code class="docutils literal"><span class="pre">1</span></code>. (Ideally, there would always be a difference, no matter
how slight, and so one entry would end up becoming <code class="docutils literal"><span class="pre">1</span></code>).</p>
<p>This can manifest as either a matrix row with two values very close to <code class="docutils literal"><span class="pre">1</span></code> or,
if DA continues to be iterated after this point, <code class="docutils literal"><span class="pre">NaN</span></code> entries in the
assignment matrix. It&#8217;s up to the caller to detect this kind of failure, and in
my experience, increasing the &#8220;cooling&#8221; ratio can help. There are functions to
restore previous values when this happens so that you don&#8217;t lose information.</p>
<p>Finally, it&#8217;s not part of DA to detect how many groups to use. That decision is
up to the caller.</p>
</div>
<div class="section" id="usage">
<h2>Usage<a class="headerlink" href="#usage" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference external" href="http://detly.github.io/detan/">API documentation</a> has details on the
API, but here&#8217;s a breakdown on how to put calling code together.</p>
<p>First, the imports. We&#8217;ll use <code class="docutils literal"><span class="pre">numpy</span></code> for putting matrices together. The two
things you&#8217;ll probably want from <code class="docutils literal"><span class="pre">detan</span></code> are:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">detan.detan</span> <span class="k">import</span> <span class="n">AssignmentAnnealing</span><span class="p">,</span> <span class="n">assignment_iteration</span>
</pre></div>
</div>
<p>Remember how one part of DA is to calculate new expectation values from old
ones? <code class="docutils literal"><span class="pre">detan</span></code> allows you to implement your own updating function for that, but
it&#8217;s quite likely you&#8217;ll want to use the one in <code class="docutils literal"><span class="pre">detan</span></code> itself. The
<code class="docutils literal"><span class="pre">assignment_iteration</span></code> function creates a closure over distances you provide.
The other name you import, <code class="docutils literal"><span class="pre">AssignmentAnnealing</span></code>, is a class for the annealing
state.</p>
<p>Next, we need the pairwise dissimilarity matrix. Remember, this is symmetric, so
I just create a triangular matrix and add it to its own transpose:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">((</span>
    <span class="p">(</span><span class="mf">0.0</span> <span class="p">,</span> <span class="mf">2.1</span> <span class="p">,</span> <span class="mf">0.10</span><span class="p">,</span> <span class="mf">0.85</span><span class="p">,</span> <span class="mf">0.2</span> <span class="p">,</span> <span class="mf">0.78</span><span class="p">),</span>
    <span class="p">(</span><span class="mf">0.0</span> <span class="p">,</span> <span class="mf">0.0</span> <span class="p">,</span> <span class="mf">0.92</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">1.01</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">),</span>
    <span class="p">(</span><span class="mf">0.0</span> <span class="p">,</span> <span class="mf">0.0</span> <span class="p">,</span> <span class="mf">0.0</span> <span class="p">,</span> <span class="mf">2.02</span><span class="p">,</span> <span class="mf">0.15</span><span class="p">,</span> <span class="mf">0.99</span><span class="p">),</span>
    <span class="p">(</span><span class="mf">0.0</span> <span class="p">,</span> <span class="mf">0.0</span> <span class="p">,</span> <span class="mf">0.0</span> <span class="p">,</span> <span class="mf">0.0</span> <span class="p">,</span> <span class="mf">1.30</span><span class="p">,</span> <span class="mf">0.31</span><span class="p">),</span>
    <span class="p">(</span><span class="mf">0.0</span> <span class="p">,</span> <span class="mf">0.0</span> <span class="p">,</span> <span class="mf">0.0</span> <span class="p">,</span> <span class="mf">0.0</span> <span class="p">,</span> <span class="mf">0.0</span> <span class="p">,</span> <span class="mf">1.05</span><span class="p">),</span>
    <span class="p">(</span><span class="mf">0.0</span> <span class="p">,</span> <span class="mf">0.0</span> <span class="p">,</span> <span class="mf">0.0</span> <span class="p">,</span> <span class="mf">0.0</span> <span class="p">,</span> <span class="mf">0.0</span> <span class="p">,</span> <span class="mf">0.0</span> <span class="p">),</span>
<span class="p">))</span>

<span class="n">distances</span> <span class="o">=</span> <span class="n">distances</span> <span class="o">+</span> <span class="n">distances</span><span class="o">.</span><span class="n">T</span>
</pre></div>
</div>
<p>Each entry represents the &#8220;distance&#8221; between two things, so the diagonal has to
be all zeros (a thing has no distance from itself). Try to eyeball how the
clustering will go — thing #0 will probably be in the same group as thing #2
(distance of <code class="docutils literal"><span class="pre">0.10</span></code>), but not thing #1 (distance of <code class="docutils literal"><span class="pre">2.1</span></code>).</p>
<p>Let&#8217;s say there are two groups:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">groups</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div>
</div>
<p>The initial assignment expectatons should be randomised (really, each row must
contain distinct entries), and they need to sum to one:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">initial_assignments</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">6</span><span class="p">,</span><span class="n">groups</span><span class="p">))</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="n">row_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">initial_assignments</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">groups</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
<span class="n">initial_assignments</span> <span class="o">=</span> <span class="n">initial_assignments</span><span class="o">/</span><span class="n">row_sum</span>
</pre></div>
</div>
<p>An <code class="docutils literal"><span class="pre">AssignmentAnnealing</span></code> object is the state of the deterministic annealling
process, including the current temperature, current assignment expectations and
the last set of values from the last temperature step. Here we give it the
closure mentioned above, an initial set of random assignments, and a ratio of
<code class="docutils literal"><span class="pre">0.73</span></code> to use for the temperature decrease.</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">annealer</span> <span class="o">=</span> <span class="n">AssignmentAnnealing</span><span class="p">(</span><span class="n">assignment_iteration</span><span class="p">(</span><span class="n">distances</span><span class="p">),</span> <span class="n">initial_assignments</span><span class="p">,</span> <span class="mf">0.73</span><span class="p">)</span>
</pre></div>
</div>
<p>This is the loop where we actually do the annealing. An outer loop decreases the
temperature, and an inner loop does the fixed point iteration (the <code class="docutils literal"><span class="pre">annealer</span></code>
object itself is an iterator that does this for you):</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">tolerance</span> <span class="o">=</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">6</span>
<span class="n">old_assignments</span> <span class="o">=</span> <span class="n">initial_assignments</span>

<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">new_assignments</span> <span class="ow">in</span> <span class="n">annealer</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">new_assignments</span> <span class="o">-</span> <span class="n">old_assignments</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">tolerance</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">old_assignments</span> <span class="o">=</span> <span class="n">new_assignments</span>
    <span class="n">annealer</span><span class="o">.</span><span class="n">cool</span><span class="p">()</span>
</pre></div>
</div>
<p>More sophisticated calling code might try to account for the problems outlined
above (<code class="docutils literal"><span class="pre">NaN</span></code> values in the expectation matrix, detecting convergence, etc.).
But the code above shows the fundamental structure of deterministic annealing.</p>
<p>Finally, the results.</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">annealer</span><span class="o">.</span><span class="n">assignments</span><span class="p">)</span>
</pre></div>
</div>
<p>...gives us:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="p">[[</span>  <span class="mf">3.29633866e-151</span>   <span class="mf">1.00000000e+000</span><span class="p">]</span>
 <span class="p">[</span>  <span class="mf">1.00000000e+000</span>   <span class="mf">2.21285560e-174</span><span class="p">]</span>
 <span class="p">[</span>  <span class="mf">1.18723351e-162</span>   <span class="mf">1.00000000e+000</span><span class="p">]</span>
 <span class="p">[</span>  <span class="mf">1.00000000e+000</span>   <span class="mf">3.17951854e-163</span><span class="p">]</span>
 <span class="p">[</span>  <span class="mf">1.80615908e-132</span>   <span class="mf">1.00000000e+000</span><span class="p">]</span>
 <span class="p">[</span>  <span class="mf">1.00000000e+000</span>   <span class="mf">1.40074506e-107</span><span class="p">]]</span>
</pre></div>
</div>
<p>Informally, the values seem to have converged to zero or one. (There&#8217;s no
<em>objective</em> way to decide this, but for the demo, let&#8217;s go with it.) So we could
just pick a completely arbitrary threshold and do this:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">annealer</span><span class="o">.</span><span class="n">assignments</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">50</span><span class="p">)</span>
</pre></div>
</div>
<p>...giving:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="kc">False</span>  <span class="kc">True</span><span class="p">]</span>
 <span class="p">[</span> <span class="kc">True</span> <span class="kc">False</span><span class="p">]</span>
 <span class="p">[</span><span class="kc">False</span>  <span class="kc">True</span><span class="p">]</span>
 <span class="p">[</span> <span class="kc">True</span> <span class="kc">False</span><span class="p">]</span>
 <span class="p">[</span><span class="kc">False</span>  <span class="kc">True</span><span class="p">]</span>
 <span class="p">[</span> <span class="kc">True</span> <span class="kc">False</span><span class="p">]]</span>
</pre></div>
</div>
<p>This tells us that, as we expected, thing #0 and thing #2 are in the same group,
and in a different group to thing #1.</p>
</div>
<div class="section" id="indices-and-tables">
<h2>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></li>
<li><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></li>
<li><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></li>
</ul>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="#">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Index</a><ul>
<li><a class="reference internal" href="#modules">Modules</a></li>
</ul>
</li>
<li><a class="reference internal" href="#deterministic-annealing">Deterministic Annealing</a><ul>
<li><a class="reference internal" href="#installation">Installation</a><ul>
<li><a class="reference internal" href="#dependencies">Dependencies</a></li>
</ul>
</li>
<li><a class="reference internal" href="#clustering-algorithms">Clustering algorithms</a></li>
<li><a class="reference internal" href="#how-deterministic-annealing-works">How deterministic annealing works</a></li>
<li><a class="reference internal" href="#limitations-and-modes-of-failure">Limitations and modes of failure</a></li>
<li><a class="reference internal" href="#usage">Usage</a></li>
<li><a class="reference internal" href="#indices-and-tables">Indices and tables</a></li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="#">Documentation overview</a><ul>
      <li>Next: <a href="detan.html" title="next chapter"><code class="docutils literal"><span class="pre">detan.detan</span></code> &#8211; deterministic annealing library</a></li>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/index.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2016, Jason Heeris.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.4.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.8</a>
      
      |
      <a href="_sources/index.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>